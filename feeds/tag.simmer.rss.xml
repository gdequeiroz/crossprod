<?xml version="1.0" encoding="utf-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Crossprod</title><link>http://nacnudus.github.io/crossprod/</link><description>R, data, and frustration</description><atom:link href="http://nacnudus.github.io/crossprod/feeds/tag.simmer.rss.xml" rel="self"></atom:link><lastBuildDate>Mon, 06 Jun 2016 00:00:00 +1200</lastBuildDate><item><title>Simmer vs SimPy: The Bank, Part II</title><link>http://nacnudus.github.io/crossprod/simmer-vs-simpy-the-bank-part-ii</link><description>&lt;h2 id="simmer-vs-simpy-rematch"&gt;Simmer vs SimPy&amp;nbsp;(rematch)&lt;/h2&gt;
&lt;p&gt;In my &lt;a href="http://nacnudus.github.io/crossprod/simmer-vs-simpy-the-bank-part-i"&gt;previous post&lt;/a&gt;, I ported &lt;a href="https://pythonhosted.org/SimPy/Tutorials/TheBank.html"&gt;Part I&lt;/a&gt; of &lt;code&gt;SimPy&lt;/code&gt;&lt;span class="quo"&gt;&amp;#8216;&lt;/span&gt;s flagship
tutorial, &lt;em&gt;The Bank&lt;/em&gt;, to &lt;code&gt;simmer&lt;/code&gt;.  This post does the same for &lt;a href="https://pythonhosted.org/SimPy/Tutorials/TheBank2.html"&gt;Part &lt;span class="caps"&gt;II&lt;/span&gt;&lt;/a&gt;, which introduces tricky concepts for tricky&amp;nbsp;customers.&lt;/p&gt;
&lt;p&gt;This post does two&amp;nbsp;things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Discusses some difficulties implementing The Bank: Part &lt;span class="caps"&gt;II&lt;/span&gt;.&lt;/li&gt;
&lt;li&gt;Suggests some reasons why simulation is hard (blame&amp;nbsp;humans).&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="the-bank"&gt;The&amp;nbsp;Bank&lt;/h2&gt;
&lt;p&gt;&lt;span class="quo"&gt;&amp;#8216;&lt;/span&gt;The Bank&amp;#8217; is a tutorial that develops &lt;span class="caps"&gt;DES&lt;/span&gt; concepts and techniques by simulating
the paths of customers at a bank.  The arrivals (customers) queue for a server
(counter), are served, and&amp;nbsp;exit.&lt;/p&gt;
&lt;h2 id="complete-code"&gt;Complete&amp;nbsp;code&lt;/h2&gt;
&lt;p&gt;The actual ported code is available &lt;a href="https://github.com/nacnudus/simmer-bank"&gt;on
GitHub&lt;/a&gt;, and I only give simple
examples in this&amp;nbsp;post.&lt;/p&gt;
&lt;h2 id="priority-and-pre-emption"&gt;Priority and&amp;nbsp;pre-emption&lt;/h2&gt;
&lt;p&gt;High-priority arrivals (customers) go straight to the front of the queue.  When
pre-emption is allowed, they can even barge they way onto a busy server,
interrupting an arrival (customer) that is already being&amp;nbsp;served.&lt;/p&gt;
&lt;p&gt;Priority and pre-emption has only recently been added to &lt;code&gt;simmer&lt;/code&gt;, and it still
feels a bit clumsy.  The complications arise because events have to be
rescheduled, and decisions have to be remade.  For&amp;nbsp;example:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;When a server is serving several arrivals at once, which one should be
  interrupted by a higher-priority arrival?  &lt;code&gt;Simmer&lt;/code&gt; already implements
  first-in-first-out (&lt;span class="caps"&gt;FIFO&lt;/span&gt;) and last-in-first-out (&lt;span class="caps"&gt;LIFO&lt;/span&gt;)&amp;nbsp;policies.&lt;/li&gt;
&lt;li&gt;When an arrival is interrupted while being served, and then resumes service,
  should they start again (repeating the first period of their service time) or
  carry on from where they left off (completing their remaining service time).
  &lt;code&gt;Simmer&lt;/code&gt; already implements these two options, but it&amp;#8217;s reasonable to suppose
  that resumption of service might come with a time penalty, and it doesn&amp;#8217;t
  currently seem to be possible to express such a&amp;nbsp;penalty.&lt;/li&gt;
&lt;li&gt;While an interrupted arrival is waiting to return to the server, where do they
  wait?  This matters in a finite queue.  Currently, &lt;code&gt;simmer&lt;/code&gt; allows the arrival
  to wait in the finite queue, even if the queue is already full and rejecting
  new arrivals.  To change this behaviour, one would have to define a policy for
  ejecting arrivals from the queue to maintain the constraint on its&amp;nbsp;size.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="balking-and-reneging"&gt;Balking and&amp;nbsp;reneging&lt;/h2&gt;
&lt;p&gt;Balking is the behaviour of an arrival that, for some reason, never enters a
queue.  The example in The Bank Tutorial is the case when a finite queue is
full, so the arrival is rejected.  An alternative might be that the arrival
decides whether or not to enter the queue according to the number of arrivals
already in it.  That scenario can already be implemented in &lt;code&gt;simmer&lt;/code&gt; by branching
based on an enquiry into the state of the&amp;nbsp;queue.&lt;/p&gt;
&lt;p&gt;Reneging is the behaviour of an arrival already in a queue, who decides to leave
it.  This isn&amp;#8217;t yet possible in &lt;code&gt;simmer&lt;/code&gt;, but the authors have indulged me in
several discussions about it, on
&lt;a href="https://github.com/r-simmer/simmer/issues"&gt;GitHub&lt;/a&gt; and in the &lt;a href="https://groups.google.com/forum/#!forum/simmer-devel"&gt;discussion
forum&lt;/a&gt;.  The difficulty,
as I currently see it, is that the &lt;code&gt;seize&lt;/code&gt; function, by handling the whole
interval between entering the queue and reaching the server, makes the queueing
period relatively inaccessible.  If one wanted an arrival to renege from one
queue and branch instead into another queue, there is no way to express that
inside the &lt;code&gt;seize&lt;/code&gt; function.  If one wanted other customers in the queue to
reassess their patience, based on customers ahead of them reneging, then there
is no way to express that idea&amp;nbsp;either.&lt;/p&gt;
&lt;p&gt;To be fair to the &lt;code&gt;simmer&lt;/code&gt; authors, these ideas weren&amp;#8217;t present in early
versions of &lt;code&gt;SimPy&lt;/code&gt; either, and were still clumsy when The Bank: Part &lt;span class="caps"&gt;II&lt;/span&gt; was
written.  It also can&amp;#8217;t be easy to separate the concept of queueing from the
&lt;code&gt;seize&lt;/code&gt; function, since this is probably the most computationally-expensive
aspect of modelling, which has, very sensibly, been implemented in&amp;nbsp;C++.&lt;/p&gt;
&lt;h2 id="interruption"&gt;Interruption&lt;/h2&gt;
&lt;p&gt;&lt;code&gt;SimPy&lt;/code&gt; provides functions for interrupting an arrival that is being served.
The examples in The Bank Tutorial don&amp;#8217;t convince me that special functions are
necessary. Why not simply increase their service time?  That&amp;#8217;s certainly how I
implemented interruptions in &lt;code&gt;simmer&lt;/code&gt;.&lt;/p&gt;
&lt;h2 id="wait-until"&gt;Wait&amp;nbsp;until&lt;/h2&gt;
&lt;p&gt;Another relatively new feature of &lt;code&gt;simmer&lt;/code&gt; is the ability to schedule the
capacity of resources at certain times.  I used schedules to implement the bank
opening in the morning, and to &amp;#8216;open the door&amp;#8217; once every 30 minutes to let in
any customers that are queueing&amp;nbsp;outside.&lt;/p&gt;
&lt;p&gt;The scheduling feature can be periodic, which is wonderful, but it isn&amp;#8217;t
currently possible to schedule a single change in capacity that then endures
indefinitely.  See
&lt;a href="https://github.com/nacnudus/simmer-bank/blob/master/17-waituntil.R"&gt;GitHub&lt;/a&gt; for
examples.  It also doesn&amp;#8217;t seem to be possible to schedule infinite&amp;nbsp;capacity.&lt;/p&gt;
&lt;h2 id="monitoring-and-plotting"&gt;Monitoring and&amp;nbsp;plotting&lt;/h2&gt;
&lt;p&gt;Here is where &lt;code&gt;simmer&lt;/code&gt; continues to excel, providing far simpler and
more-intuitive monitoring of arrivals, resources and attributes, in handy data
frames for straightforward plotting with any graphics&amp;nbsp;library.&lt;/p&gt;
&lt;h2 id="simulation-is-hard"&gt;Simulation is&amp;nbsp;hard&lt;/h2&gt;
&lt;p&gt;Because human behaviour is hard.  Real-life systems involving humans are
massively parallel.  Every actor processes his/her own activities onto the
universal time-line.  As long as computers have very finite numbers of
processors, simulation libraries will have to find ways to express this
parallelism in a way that computers can serialise.  When actors in a system
influence each-other&amp;#8217;s behaviour, the computational difficulties of serialising
their behaviour begin to meet the boundaries of efficient&amp;nbsp;computation.&lt;/p&gt;
&lt;p&gt;I must thank the authors of &lt;code&gt;simmer&lt;/code&gt; for their generous attitude towards
suggestions and discussion, like so many R developers.  I have no doubt that
this post will soon become obsolete by their&amp;nbsp;efforts.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Duncan Garmonsway</dc:creator><pubDate>Mon, 06 Jun 2016 00:00:00 +1200</pubDate><guid>tag:nacnudus.github.io,2016-06-06:crossprod/simmer-vs-simpy-the-bank-part-ii</guid><category>R</category><category>Simmer</category><category>SimPy</category></item><item><title>Simmer vs SimPy: The Bank, Part I</title><link>http://nacnudus.github.io/crossprod/simmer-vs-simpy-the-bank-part-i</link><description>&lt;h2 id="simmer-vs-simpy"&gt;Simmer vs&amp;nbsp;SimPy&lt;/h2&gt;
&lt;p&gt;Which package would be easier for teaching queueing theory?  Python 2.7&amp;#8217;s
&lt;a href="https://pythonhosted.org/SimPy/SimPy_Overview.html"&gt;&lt;code&gt;SimPy&lt;/code&gt;&lt;/a&gt;, designed for
(as far as I can tell) lecturing, by Tony Vigneau at my alma mater, Vic Uni
Wellington &lt;span class="caps"&gt;NZ&lt;/span&gt;, or &lt;a href="http://r-simmer.org/"&gt;&lt;code&gt;simmer&lt;/code&gt;&lt;/a&gt;, designed by Bart Smeets and
Iñaki Ucar to (as far as I can tell) actually&amp;nbsp;use?&lt;/p&gt;
&lt;p&gt;The &lt;code&gt;simmer&lt;/code&gt; package is a relatively new R package for discrete event simulation
(&lt;span class="caps"&gt;DES&lt;/span&gt;).  It&amp;#8217;s an exciting development, because there isn&amp;#8217;t a lot of open-source
&lt;span class="caps"&gt;DES&lt;/span&gt; software.  &lt;code&gt;SimPy&lt;/code&gt; seems to be the only serious competitor for teaching
&lt;span class="caps"&gt;DES&lt;/span&gt; and queueing&amp;nbsp;theory.&lt;/p&gt;
&lt;p&gt;This post does three&amp;nbsp;things:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ports the code of the main &lt;code&gt;SimPy&lt;/code&gt; tutorial &lt;a href="https://pythonhosted.org/SimPy/Tutorials/TheBank.html"&gt;&amp;#8216;The Bank&amp;#8217;&lt;/a&gt; to &lt;code&gt;simmer&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Opines that &lt;code&gt;simmer&lt;/code&gt; would be easier to teach as part of a queueing theory&amp;nbsp;course.&lt;/li&gt;
&lt;li&gt;Pursues a random red&amp;nbsp;herring.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="why-not-simpy-3"&gt;Why not SimPy&amp;nbsp;3?&lt;/h2&gt;
&lt;p&gt;I use &lt;code&gt;SimPy&lt;/code&gt; 2 (for Python 2), because it is the last version developed by the
original author, because it was the version I was taught, only last year, and
because, in one crucial respect (monitoring), it&amp;#8217;s &lt;a href="https://simpy.readthedocs.io/en/latest/topical_guides/monitoring.html"&gt;much easier to
use&lt;/a&gt;.&lt;/p&gt;
&lt;h2 id="the-bank"&gt;The&amp;nbsp;Bank&lt;/h2&gt;
&lt;p&gt;&lt;span class="quo"&gt;&amp;#8216;&lt;/span&gt;The Bank&amp;#8217; is a tutorial that develops &lt;span class="caps"&gt;DES&lt;/span&gt; concepts and techniques by simulating
the paths of customers at a bank.  The arrivals (customers) queue for a server
(counter), are served, and&amp;nbsp;exit.&lt;/p&gt;
&lt;h2 id="complete-example"&gt;Complete&amp;nbsp;example&lt;/h2&gt;
&lt;p&gt;The actual ported code is available &lt;a href="https://github.com/nacnudus/simmer-bank"&gt;on
GitHub&lt;/a&gt;, and I only give simple
examples in this post.  The first example is&amp;nbsp;complete.&lt;/p&gt;
&lt;p&gt;First, &lt;code&gt;SimPy&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot; bank01: The single non-random Customer &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;           
&lt;span class="kn"&gt;from&lt;/span&gt; &lt;span class="nn"&gt;SimPy.Simulation&lt;/span&gt; &lt;span class="kn"&gt;import&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;                           

&lt;span class="c"&gt;## Model components -----------------------------        &lt;/span&gt;

&lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="nc"&gt;Customer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Process&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;                                 
    &lt;span class="sd"&gt;&amp;quot;&amp;quot;&amp;quot; Customer arrives, looks around and leaves &amp;quot;&amp;quot;&amp;quot;&lt;/span&gt;

    &lt;span class="k"&gt;def&lt;/span&gt; &lt;span class="nf"&gt;visit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;timeInBank&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;                          
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; Here I am&amp;quot;&lt;/span&gt;               
        &lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;hold&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;timeInBank&lt;/span&gt;                       
        &lt;span class="k"&gt;print&lt;/span&gt; &lt;span class="n"&gt;now&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="s"&gt;&amp;quot; I must leave&amp;quot;&lt;/span&gt;            

&lt;span class="c"&gt;## Experiment data ------------------------------&lt;/span&gt;

&lt;span class="n"&gt;maxTime&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;100.0&lt;/span&gt;     &lt;span class="c"&gt;# minutes                            &lt;/span&gt;
&lt;span class="n"&gt;timeInBank&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;10.0&lt;/span&gt;   &lt;span class="c"&gt;# minutes&lt;/span&gt;

&lt;span class="c"&gt;## Model/Experiment ------------------------------&lt;/span&gt;

&lt;span class="n"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;                                             
&lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Customer&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;name&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Klaus&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                               
&lt;span class="n"&gt;activate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;&lt;span class="n"&gt;visit&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;timeInBank&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;&lt;span class="n"&gt;at&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mf"&gt;5.0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;                   
&lt;span class="n"&gt;simulate&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;until&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="n"&gt;maxTime&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;   
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;## 5.0 Klaus  Here I am
## 15.0 Klaus  I must leave
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Next, &lt;code&gt;simmer&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;# bank01: The single non-random customer&lt;/span&gt;
&lt;span class="kp"&gt;suppressMessages&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kn"&gt;library&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;simmer&lt;span class="p"&gt;))&lt;/span&gt;

&lt;span class="c1"&gt;## Experiment data ------------------------------&lt;/span&gt;

maxTime &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;100&lt;/span&gt;     &lt;span class="c1"&gt;# minutes                            &lt;/span&gt;
timeInBank &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; &lt;span class="m"&gt;10&lt;/span&gt;   &lt;span class="c1"&gt;# minutes&lt;/span&gt;

&lt;span class="c1"&gt;## Model components -----------------------------        &lt;/span&gt;

customer &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; 
  create_trajectory&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Customer&amp;#39;s path&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
  timeout&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;timeInBank&lt;span class="p"&gt;})&lt;/span&gt; 

&lt;span class="c1"&gt;## Model/Experiment ------------------------------&lt;/span&gt;

bank &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; simmer&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;bank&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; add_generator&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Customer&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; customer&lt;span class="p"&gt;,&lt;/span&gt; at&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;5&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;## simmer environment: bank | now: 0 | next: 5
## { Generator: Customer | monitored: 1 | n_generated: 1 }
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; run&lt;span class="p"&gt;(&lt;/span&gt;until &lt;span class="o"&gt;=&lt;/span&gt; maxTime&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;## simmer environment: bank | now: 15 | next: 
## { Generator: Customer | monitored: 1 | n_generated: 1 }
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_mon_arrivals
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;##        name start_time end_time activity_time finished replication
## 1 Customer0          5       15            10     TRUE           1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Already there are several differences that might make teaching queueing theory
with &lt;code&gt;simmer&lt;/code&gt; easier than with &lt;code&gt;SimPy&lt;/code&gt;:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;The difference between &lt;code&gt;from X import Y&lt;/code&gt; and &lt;code&gt;Import X&lt;/code&gt; isn&amp;#8217;t&amp;nbsp;relevant.&lt;/li&gt;
&lt;li&gt;Whitespace doesn&amp;#8217;t&amp;nbsp;matter.&lt;/li&gt;
&lt;li&gt;The difference between integer and floating-point types doesn&amp;#8217;t matter&amp;nbsp;here.&lt;/li&gt;
&lt;li&gt;Arguments don&amp;#8217;t have to be&amp;nbsp;defined.&lt;/li&gt;
&lt;li&gt;References don&amp;#8217;t have to be&amp;nbsp;passed.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;self&lt;/code&gt; is&amp;nbsp;irrelevant.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; is more intuitive than &lt;code&gt;yield&lt;/code&gt; (&lt;code&gt;yield&lt;/code&gt; describes how the class
  behaves in the implementation of the &lt;span class="caps"&gt;DES&lt;/span&gt;, as it yields control back to the
  clock, whereas &lt;code&gt;timeout&lt;/code&gt; describes what the function does in the mind of the&amp;nbsp;modeller).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;But there is one point that could be tricky, and that soon becomes&amp;nbsp;important:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;timeout&lt;/code&gt; and &lt;code&gt;add_generator&lt;/code&gt; both expect &lt;em&gt;functions&lt;/em&gt;, rather than vectors, to
  control (inter-)arrival time and timeout duration.  It would be nice to have
  syntactic sugar to handle vectors.  The reason for the functions is that, when
  a model is run indefinitely, a function can continue generating new arrival
  times and timeout durations, whereas a vector will soon be&amp;nbsp;exhausted.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2 id="example-fragments"&gt;Example&amp;nbsp;fragments&lt;/h2&gt;
&lt;p&gt;Implementing the rest of the examples brought up a few other interesting&amp;nbsp;points.&lt;/p&gt;
&lt;h3 id="generate-more-than-one-arrival"&gt;Generate more than one&amp;nbsp;arrival&lt;/h3&gt;
&lt;p&gt;In the &lt;code&gt;SimPy&lt;/code&gt; examples, to generate &lt;code&gt;n &amp;gt; 1&lt;/code&gt; arrivals, the &lt;code&gt;activate&lt;/code&gt; code to
generate them moves inside the &lt;code&gt;Source&lt;/code&gt; class.  To explain why requires a quite
a lot of understanding/intuition of object-oriented programming that isn&amp;#8217;t
relevant to learning about queuing theory.  &lt;code&gt;Simmer&lt;/code&gt; doesn&amp;#8217;t present this&amp;nbsp;difficulty.&lt;/p&gt;
&lt;h3 id="limit-the-number-of-arrivals"&gt;Limit the number of&amp;nbsp;arrivals&lt;/h3&gt;
&lt;p&gt;Arrivals with random inter-arrival times would be generated indefinitely by
&lt;code&gt;bank %&amp;gt;% add_generator("Customer", customer, function() {runif(1)})&lt;/code&gt;.  To limit
this to &lt;code&gt;n = 10&lt;/code&gt; arrivals, you might try &lt;code&gt;times &amp;lt;- runif(10); bank %&amp;gt;%
add_generator("Customer", customer, times)&lt;/code&gt;, but it doesn&amp;#8217;t work, because
&lt;code&gt;add_generator&lt;/code&gt; expects a function that &lt;em&gt;will&lt;/em&gt; supply inter-arrival times, not a
vector that &lt;em&gt;does&lt;/em&gt; supply&amp;nbsp;them.&lt;/p&gt;
&lt;p&gt;&lt;code&gt;Simmer&lt;/code&gt; provides a handy function, &lt;code&gt;at()&lt;/code&gt;, to
convert a vector to function, so you could do &lt;code&gt;add_generator("Customer", customer,
at(runif(10)))&lt;/code&gt;, except that this still doesn&amp;#8217;t work.  That&amp;#8217;s because &lt;code&gt;at()&lt;/code&gt;
is designed to convert &lt;em&gt;arrival&lt;/em&gt; times into &lt;em&gt;inter-arrival&lt;/em&gt; times, but the
&lt;code&gt;runif&lt;/code&gt; function is being used to provide &lt;em&gt;inter-arrival&lt;/em&gt; times in the first
place.  The final fix is to do &lt;code&gt;add_generator("Customer", customer, at(c(0,
cumsum(runif(10)))))&lt;/code&gt;.&lt;/p&gt;
&lt;h3 id="joining-the-shortest-queue"&gt;Joining the shortest&amp;nbsp;queue&lt;/h3&gt;
&lt;p&gt;This is a pain in both &lt;code&gt;SimPy&lt;/code&gt; and &lt;code&gt;simmer&lt;/code&gt;.  The &lt;code&gt;SimPy&lt;/code&gt; example creates a
method to return the length of each queue, and then the following code iterates
through the results until a queue is&amp;nbsp;chosen:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;# Select the shortest queue&lt;/span&gt;
&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt; &lt;span class="ow"&gt;in&lt;/span&gt; &lt;span class="nb"&gt;range&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Nc&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;                                         
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="n"&gt;Qlength&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="ow"&gt;or&lt;/span&gt; &lt;span class="n"&gt;Qlength&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;i&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Qlength&lt;/span&gt;&lt;span class="p"&gt;):&lt;/span&gt;
        &lt;span class="n"&gt;choice&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;i&lt;/span&gt;  &lt;span class="c"&gt;# the chosen queue number                &lt;/span&gt;
        &lt;span class="k"&gt;break&lt;/span&gt;

&lt;span class="c"&gt;# Join the queue&lt;/span&gt;
&lt;span class="k"&gt;yield&lt;/span&gt; &lt;span class="n"&gt;request&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="bp"&gt;self&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="n"&gt;counters&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;choice&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;In &lt;code&gt;simmer&lt;/code&gt;, this is done by&amp;nbsp;branching:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;customer &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; 
  create_trajectory&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Customer&amp;#39;s path&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
    branch&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
             &lt;span class="c1"&gt;# Select the shortest queue&lt;/span&gt;
             &lt;span class="kp"&gt;which.min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_server_count&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
                           bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_queue_count&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                         bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_server_count&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
                           bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_queue_count&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))&lt;/span&gt;
         &lt;span class="p"&gt;},&lt;/span&gt;
         merge &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kp"&gt;rep&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kc"&gt;TRUE&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="c1"&gt;# Join the first queue, if it was chosen&lt;/span&gt;
         create_trajectory&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;branch1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
           seize&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
           timeout&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;rexp&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;timeInBank&lt;span class="p"&gt;)})&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
           release&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
         &lt;span class="c1"&gt;# Otherwise join the second queue, if it was chosen&lt;/span&gt;
         create_trajectory&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;branch2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
           seize&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
           timeout&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;rexp&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;timeInBank&lt;span class="p"&gt;)})&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
           release&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;I mucked about for a while trying to avoid branching by using attributes to name
the server at &lt;code&gt;seize&lt;/code&gt; time. I won&amp;#8217;t explain attributes here because they&amp;#8217;re
covered in the excellent &lt;code&gt;simmer&lt;/code&gt; &lt;a href=""&gt;vignettes&lt;/a&gt;, but basically the following
code doesn&amp;#8217;t work because attributes are only available to certain arguments,
the &lt;code&gt;resource&lt;/code&gt; argument not among them, only &lt;code&gt;amount&lt;/code&gt; and perhaps
&lt;code&gt;priority&lt;/code&gt; and &lt;code&gt;preemptible&lt;/code&gt;.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;# This doesn&amp;#39;t work:&lt;/span&gt;
customer &lt;span class="o"&gt;&amp;lt;-&lt;/span&gt; 
  create_trajectory&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;Customer&amp;#39;s path&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
    &lt;span class="c1"&gt;# Attributes can be set, to choose the queue&lt;/span&gt;
    set_attribute&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                  &lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="kp"&gt;which.min&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;c&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_server_count&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
                                  bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_queue_count&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter1&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt;
                                bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_server_count&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt;
                                  bank &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt; get_queue_count&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter2&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;)))})&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
    &lt;span class="c1"&gt;# But they aren&amp;#39;t available in the `resource` argument of `seize` for naming&lt;/span&gt;
    &lt;span class="c1"&gt;# the server, so this doesn&amp;#39;t work.&lt;/span&gt;
    seize&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;attrs&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="kp"&gt;paste0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; attrs&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;])})&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
    timeout&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;rexp&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="m"&gt;1&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;timeInBank&lt;span class="p"&gt;)})&lt;/span&gt; &lt;span class="o"&gt;%&amp;gt;%&lt;/span&gt;
    release&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kr"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;attrs&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="kp"&gt;paste0&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; attrs&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;&amp;quot;counter&amp;quot;&lt;/span&gt;&lt;span class="p"&gt;])})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3 id="monitoring"&gt;Monitoring&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;Simmer&lt;/code&gt; has a killer feature: everything is monitored automatically, and
reported in handy data frames.  This works especially well when doing many&amp;nbsp;replications.&lt;/p&gt;
&lt;p&gt;But it isn&amp;#8217;t obvious how to do the equivalent of, in Python, injecting &lt;code&gt;print&lt;/code&gt;
or &lt;code&gt;cat&lt;/code&gt; commands to describe the state of particular arrivals and servers.
Presumably something could be done in the functions passed to &lt;code&gt;dist&lt;/code&gt; arguments.
In this sence, &lt;code&gt;simmer&lt;/code&gt; is more declarative; like a story book, where the text
describes the characters, but the characters don&amp;#8217;t really exist.  &lt;code&gt;Simmer&lt;/code&gt;
describes arrivals and servers, but they don&amp;#8217;t really exist, and can&amp;#8217;t be
directly interacted&amp;nbsp;with.&lt;/p&gt;
&lt;h2 id="random-red-herring"&gt;Random red&amp;nbsp;herring&lt;/h2&gt;
&lt;p&gt;Python 2.7, R and &lt;span class="caps"&gt;MATLAB&lt;/span&gt; all use the Mersenne-Twister algorithm by default.  But
none of them matches.  The &lt;code&gt;numpy&lt;/code&gt; Python package &lt;a href="http://www.walkingrandomly.com/?p=5479"&gt;&lt;em&gt;does&lt;/em&gt; match
&lt;span class="caps"&gt;MATLAB&lt;/span&gt;&lt;/a&gt; (except for seed = 0), but not&amp;nbsp;R.&lt;/p&gt;
&lt;p&gt;Two potential solutions&amp;nbsp;are:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Generate any old random numbers, write them to disk, and read them into both
  Python and&amp;nbsp;R.&lt;/li&gt;
&lt;li&gt;Use &lt;code&gt;rpy2&lt;/code&gt; to use R&amp;#8217;s random number generator from within&amp;nbsp;Python.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;I used &lt;code&gt;rpy2&lt;/code&gt;, but it wasn&amp;#8217;t long before I encountered a more serious problem.
When random draws are conducted in more than one part of the code, the
programmer can&amp;#8217;t control the order of the draws.  That&amp;#8217;s up to &lt;code&gt;SimPy&lt;/code&gt; and
&lt;code&gt;simmer&lt;/code&gt;.  At that point, I gave&amp;nbsp;up.&lt;/p&gt;</description><dc:creator xmlns:dc="http://purl.org/dc/elements/1.1/">Duncan Garmonsway</dc:creator><pubDate>Wed, 11 May 2016 00:00:00 +1200</pubDate><guid>tag:nacnudus.github.io,2016-05-11:crossprod/simmer-vs-simpy-the-bank-part-i</guid><category>R</category><category>Simmer</category><category>SimPy</category></item></channel></rss>